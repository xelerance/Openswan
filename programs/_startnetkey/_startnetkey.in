#!/bin/sh
# Netkey startup script
# Copyright (C) 2007 Ken Bantoft, Paul Wouters
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

me='ipsec _startnetkey'		# for messages

modules=/proc/modules
# full rp_filter path is $rpfilter1/interface/$rpfilter2
rpfilter1=/proc/sys/net/ipv4/conf
rpfilter2=rp_filter
# %unchanged or setting (0, 1, or 2)
rpfiltercontrol=0
kamepfkey=/proc/net/pfkey

info=/dev/null
log=daemon.error
for dummy
do
	case "$1" in
	--log)		log="$2" ; shift	;;
	--info)		info="$2" ; shift	;;
	--debug)	debug="$2" ; shift	;;
	--omtu)		omtu="$2" ; shift	;;
	--fragicmp)	fragicmp="$2" ; shift	;;
	--hidetos)	hidetos="$2" ; shift	;;
	--rpfilter)	rpfiltercontrol="$2" ; shift	;;
	--)	shift ; break	;;
	-*)	echo "$me: unknown option \`$1'" >&2 ; exit 2	;;
	*)	break	;;
	esac
	shift
done


logger -p $log -t ipsec_setup "Using NETKEY(XFRM) stack"


# Code to determine default route on Linux, taken from _startklips 
defaultinterface() {
	phys=`netstat -nr |
		awk '$1 == "0.0.0.0" && $3 == "0.0.0.0" { print $NF; exit 0 }'`
	if test " $phys" = " "
	then
		echo "no default route, %defaultroute cannot cope!!!"
		exit 1
	fi
        addr=
        eval `ifconfig $phys |
                awk '$1 == "inet" && $2 ~ /^addr:/ && $NF ~ /^Mask:/ {
                        gsub(/:/, " ", $0)
                        print "addr=" $3
                        other = $5
                        if ($4 == "Bcast")
                                print "type=broadcast"
                        else if ($4 == "P-t-P")
                                print "type=pointopoint"
                        else if (NF == 5) {
                                print "type="
                                other = ""
                        } else
                                print "type=unknown"
                        print "otheraddr=" other
                        print "mask=" $NF
                }'`
        if test " $addr" = " "
        then
                echo "unable to determine address of \`$phys'"
                exit 1
        fi


	nexthop=`netstat -nr |
		awk '$1 == "0.0.0.0" && $3 == "0.0.0.0" { print $2; exit 0 }'` 

	(
	echo "defaultroutephys=$phys"
        echo "defaultrouteaddr=$addr"
		if test " $2" = " 0.0.0.0"
                then
                	# this happens on people with ppp interfaces with 'route add default dev ppp0'.
                        echo "defaultroutenexthop=%direct"
                else
                        echo "defaultroutenexthop=$nexthop"
                fi
                ) >>$info
}

# log only to syslog, not to stdout/stderr
logonly() {
	logger -p $log -t ipsec_setup
}


# main line

	# Go find us a default Interface
 	defaultinterface;

	if test -f $modules
	then
		# load hardware random related modules - some changed names over time
		echo Trying hardware random, this may fail, which is okay.
		modprobe -qv hw_random 2>/dev/null
		modprobe -qv hwrng 2>/dev/null
		modprove -qv amd-rng 2>/dev/null
		modprobe -qv intel-rng 2>/dev/null

		
		# load all NETKEY modules
		echo -n Trying to load all NETKEY modules:
		for mod in xfrm6_tunnel xfrm6_mode_tunnel xfrm6_mode_beet xfrm6_mode_ro \
			xfrm6_mode_transport xfrm4_mode_transport xfrm4_mode_tunnel \
			xfrm4_tunnel xfrm4_mode_beet esp4 esp6 ah4 ah6 ipcomp ipcomp6 af_key
		   do
			echo -n $mod
			modprobe -qv $mod 2> /dev/null
		   done
		# xfrm_user is the old name for xfrm4_tunnel - backwards compatibility
		modprobe -qv xfrm_user 2> /dev/null


		# padlock must load before aes module
		echo Trying VIA padlock driver, this may fail, which is okay.
		modprobe -qv padlock 2>/dev/null

		# load the most common ciphers/algo's
		# aes-x86_64 has higher priority in via crypto api
		echo Trying to load Crypto API modules, some may fail, which is okay.
		for crypto in aes-x86_64 aes des sha512 sha256 md5 cbc xcbc ecb twofish blowfish serpent 
		   do
			echo -n $crypto
			modprobe -qv $crypto 2> /dev/null
		   done
	fi


	if ip xfrm state > /dev/null 2>&1
	then
		ip xfrm state flush
		ip xfrm policy flush
	elif type setkey > /dev/null 2>&1
	then
	 	# Check that the setkey command is available.
         	setkeycmd= 	 
         	PATH=$PATH:/usr/local/sbin 	 
         	for dir in `echo $PATH | tr ':' ' '` 	 
         	do 	 
                	if test -f $dir/setkey -a -x $dir/setkey 	 
                 	then
                         	setkeycmd=$dir/setkey
                         	break                   # NOTE BREAK OUT 
                	fi
         	done
        	$setkeycmd -F
        	$setkeycmd -FP
	else
	
        	echo "WARNING: cannot flush state/policy database -- \`$1'. Install a newer version of iproute/iproute2 or install the ipsec-tools package to obtain the setkey command." |
                	logger -s -p daemon.error -t ipsec_setup
	fi


exit 0
